#!/usr/bin/env python3
import os, csv
from colorama import Fore, Back, Style
from datetime import date, datetime
import time
from tqdm import tqdm
import numpy as np
import multiprocessing as mp
from math import *
#import itertools
from scipy.cluster.vq import kmeans
from random import uniform
import shutil

class general_setup:
    def __init__(self, src_dir, fin_dir, t_name, s_name, s_type):
        self.tree_name = t_name
        self.source_dir = src_dir  # directory where are located the data from LiDAR (TLS) scanning and the obj file of wooden skeleton object
        self.final_dir = fin_dir  # directory where the final 3D models and associated files should be saved
        self.check_folder(self.final_dir)
        self.pos_path = os.path.join(self.final_dir, t_name + '_shoot_distribution')  # base of the position file path and filename (positions of 3D shoot models)
        self.cur_pos_path = self.pos_path + '_cur.csv'  # specific filename of current shoot positions
        self.old_pos_path = self.pos_path + '_old.csv'  # specific filename of older shoot positions
        self.wooden_obj_orig_path = os.path.join(self.source_dir, t_name + '_wooden_parts_filled.obj')  # path to obj file with wooden skeleton generated by P. Sloup algorithm
        self.wooden_obj_fin_path = os.path.join(self.final_dir, t_name + '_wooden_parts_filled_scaled.obj')  # path of the obj file after scaling according to desired high of the tree
        if s_type != '':
            shoot_type_d = '_'+s_type
        else:
            shoot_type_d = ''
        self.tree_obj_path = os.path.join(self.final_dir,t_name+'_whole_tree%s.obj' % shoot_type_d) # path to the obj file with components of whole tree (current and older shoots and  wooden skeleton)
        self.shoot_path = os.path.join(self.source_dir,'shoots',s_name+'.obj')  # path to the shoot object
        # ----------------------------------------------------------------------------------------------------

    def transformation(self, tree_name, required_height):
        """
        Create a obj file from all lidar ascii files with given tree name. Transform coordinates of the vegetation data as
        they are in the same place as the wooden skeleton of the tree.
        @param veg_path: Path to the vegetation files.
        @param ske_path: Path to the wooden skeleton file.
        @param tree_name: Name of the tree.
        @param required_height: Height, to which we want to scale the final tree
        @return: max_veg
        """
        print(Back.BLUE+'Transformation of original point cloud:'+Style.RESET_ALL)
        start_time = time.time()
        print(self.source_dir)
        list_veg_path, list_woo_path = self.get_files(tree_name, self.source_dir)
        list_veg_path.sort() # for the right order in paralel for cycle
        list_woo_path.sort()
        veg_all_path = os.path.join(self.source_dir, tree_name + '_all.obj')
        veg_all_file = open(veg_all_path, 'w')
        max_skeleton = self.find_max_z(self.wooden_obj_orig_path)
        if required_height == 0:
            scale_coef = 1
        else:
            scale_coef = required_height/max_skeleton[1]
        self.scale_obj_file(scale_coef, self.wooden_obj_orig_path, self.wooden_obj_fin_path)
        max_wooden = [0, 0, 0] # will be the final height of the wooden parts point cloud
        max_corr_coef = 0
        if len(list_veg_path) == len(list_woo_path):
            for woo_file, veg_file in tqdm(zip(list_woo_path, list_veg_path)):
                if woo_file.split('-')[:-1] != veg_file.split('-')[:-1]:
                    print('The file ' + woo_file + ' or ' + veg_file + ' doesn\'t have corresponding file.')
                    exit()
                try:
                    b_woo_path = os.path.join(self.source_dir, woo_file + '_orig.obj')
                    max_woo = self.find_max_z(b_woo_path) # is max height of the single file of wooden parts point cloud (if there are multiple scans from TLS scanning)
                    if max_wooden[1] < max_woo[1]:
                        max_wooden = max_woo
                except TypeError:
                    pass # eh... I can't remember, what exactly is this catching
                try:
                    l_veg_path = os.path.join(self.source_dir, veg_file)
                    b_veg_path = l_veg_path + '_orig.obj' # lidar file tranformed to obj format
                    b_veg_trans_path = l_veg_path + '_trans.obj' # original data transposed to the same coordinates as the wooden skeleton
                    b_veg_scale_path = l_veg_path + '.obj' # transposed data scaled to recquired height
                    max_vegetation = self.find_max_z(b_veg_path) 
                    corr_coef = max_vegetation[1] - max_wooden[1]
                    if max_corr_coef < corr_coef:
                        max_corr_coef = corr_coef
                    self.trans_coordinates(b_veg_path, b_veg_trans_path, max_vegetation, max_skeleton, corr_coef)
                    self.scale_obj_file(scale_coef, b_veg_trans_path, b_veg_scale_path)
                    veg_file = open(b_veg_scale_path, 'r')
                    veg_all_file.write(veg_file.read())
                    veg_file.close()
                except TypeError:
                    exit()
            veg_all_file.close()

            print('Final transformation of all files are done.')
            print('It takes %s seconds.' % (time.time()-start_time))
            print('--------------------------------------------------------------')
            return scale_coef*(max_skeleton[1]+max_corr_coef)
        else:
            print('The number of foliage files doesn\'t match with number of wooden files.')
            exit()

    def find_max_z(self, coo_path):
        """
        Find maximum of z coordinates in obj file.
        @param coo_path: path to file when we want to find the maximum
        @return: coordinates of point with maximal z coordinate
        """
        t_file = open(coo_path, 'r')
        t_csv_file = csv.reader(t_file, delimiter=' ')
        t_max = -100
        for row in t_csv_file:
            if row[0] == 'v' and float(row[-2]) > t_max:
                t_max = float(row[-2])
                max_row = [float(row[1]), float(row[2]), float(row[3])]
        t_file.close()
        return max_row

    def trans_coordinates(self, coo_old_path, coo_new_path, max_veg, max_ske, corr_coef):
        """
        Translate the coordinates of the vegetation to the coordinates of wooden part. Produce a file with changed
        coordinates.
        @param coo_old_path: path to the file which we want to translate
        @param coo_new_path: path to the file which was translated
        @param max_veg: voxel coordinates with max z value of vegetation voxels
        @param max_ske: voxel coordinates with max z value of wooden parts
        @param corr_coef: correction coefficient for z coordinate correction
        """
        t_file_r = open(coo_old_path, 'r')
        t_csv_file_r = csv.reader(t_file_r, delimiter=' ')
        t_file_w = open(coo_new_path, 'w')
        t_csv_file_w = csv.writer(t_file_w, delimiter=' ')
        coo_1 = (max_ske[0]) - (max_veg[0])
        coo_2 = (max_ske[1]) - (max_veg[1]) + corr_coef  # because the wooden parts ends lower then the vegetation
        coo_3 = (max_ske[2]) - (max_veg[2])
        vect = [coo_1, coo_2, coo_3]
        for row in t_csv_file_r:
            if row[0] == 'v':
                t_line = [row[0], float(row[1]) + vect[0], float(row[2]) + vect[1], float(row[3]) + vect[2]]
                t_csv_file_w.writerow(t_line)
            else:
                t_csv_file_w.writerow(row)
        t_file_r.close()
        t_file_w.close()

    def scale_obj_file(self, s_coef, obj_path, scaled_obj_path):
        t_file_r = open(obj_path, 'r')
        t_csv_file_r = csv.reader(t_file_r, delimiter=' ')
        t_file_w = open(scaled_obj_path, 'w')
        t_csv_file_w = csv.writer(t_file_w, delimiter=' ')
        for row in t_csv_file_r:
            if row[0] == 'v':
                t_line = [row[0], float(row[1])*s_coef, float(row[2])*s_coef, float(row[3])*s_coef]
                t_csv_file_w.writerow(t_line)
            else:
                t_csv_file_w.writerow(row)
        t_file_r.close()

    def get_files(self, tree_name, veg_path):
        """
        Future plan: make it user defined, that user select the files which are what, for more general usage of the script
        Find all the lidar files with vegetation data.
        @param tree_name: Name of the tree which we are interested
        @param veg_path: Path to the files, where we expected the data files
        @return: list of files
        """
        t_list = os.listdir(veg_path)
        t_list.sort()
        file_list_veg = []
        file_list_woo = []
        for i_file in t_list:
            t_split = i_file.split('-')
            if len(t_split) > 1:
                t_name = i_file.split('-')[0]
                t_cat = i_file.split('-')[3]
                t_form = i_file.split('.')
                if t_name == tree_name and len(t_form) == 1:
                    if t_cat[0] == 'j':  # j means that is point cloud with needles (jehlice)
                        file_list_veg.append(i_file)

                    elif t_cat[0] == 'k':  # k means the point cloud of wooden parts (kmen (asi))
                        file_list_woo.append(i_file)
                    else:
                        continue # I want to skip the rest of the loop in this condition
                    i_path = os.path.join(self.source_dir, i_file)
                    b_i_path = i_path + '_orig.obj'
                    self.load_lidar(i_path, b_i_path) # converting the lidar file to obj format
        if not file_list_veg:
            print(
                "Please check the path to the tree files and if the name of tree is correct and the name of files are separated with -")
        else:
            print('Found files: ', file_list_veg)
            return file_list_veg, file_list_woo

    def load_lidar(self, lidar_path, blender_path):
        """
        Load lidar file and create a blender obj file.
        @param lidar_path - path to the ascii file with lidar coordinates
        @param blender_path - path to the blender obj file with lidar coordinate
        """
        lidar_file = open(lidar_path, 'r')
        lidar_csv_file = csv.reader(lidar_file, delimiter=' ')
        blender_file = open(blender_path, 'w')
        blender_csv_file = csv.writer(blender_file, delimiter=' ')
        blender_csv_file.writerow(['# Transformed from %s to %s' % (lidar_path,blender_path)])
        blender_csv_file.writerow(['# Transformed (file created): %s %s' % (date.today().strftime("%B %d, %Y"), datetime.now().strftime("%d/%m/%Y %H:%M:%S"))])
        blender_csv_file.writerow(['# '])
        blender_csv_file.writerow(['g Tree_mass'])
        for row in lidar_csv_file:
            t_line = []
            t_line.extend(['v', row[0], row[2], row[1]])
            blender_csv_file.writerow(t_line)
            del t_line
        lidar_file.close()
        blender_file.close()

    def check_folder(self, folder_path):
        if not os.path.isdir(folder_path):
            os.makedirs(folder_path)
            print(Fore.GREEN + 'The folder %s was created.' % folder_path + Style.RESET_ALL )

class Tree:
    def __init__(self, t_name, cluster_cube_size, shoot_area, lai, hull_cube_size, general_tree_setup):
        self.name = t_name # name of the tree (ID or whatever)
        self.cluster_cs = cluster_cube_size # cube/voxel size for computing the positions of the shoots
        self.s_area = shoot_area # shoot area computed by blender
        self.LAI = lai # required LAI value (pure LAi, only needles)
        
        self.center = [0,0] # center of tree - the default value if it is not define/cimpute differently
        self.env_cs = hull_cube_size # cube/voxel size for the hull(envelope) calculation
        self.gen_setup = general_tree_setup
        self.all_points = [] # all points in foliage point cloud
        self.all_pos = [] # all positions of the future shoots
        self.current_pos = [] # positions of future shoots on the edge of the tree crown => current shoots
        self.older_pos = [] # positions of future shoots insude the tree crown => older shoots
        self.crown_projection_area = 0

    #def set_opt_cluster_cs(self):
        #""" 
        #find the optimal cluster cube size
        #"""

    #def set_opt_hull_cs(self):
        #""" 
        #find the optimal hull cube size (hull is more precise than envelope phrase - need to be changed in the rest of the code)
        #"""
    
    def initiate_tree(self, max_vegetation):
        self.max_veg = self.gen_setup.transformation(self.name, max_vegetation) # the maximum z-coordinate of the whole point cloud
        self.load_points(self.gen_setup.source_dir)
        self.center = [np.mean(np.array(self.all_points)[:,0]),np.mean(np.array(self.all_points)[:,2])] # compute_center(self.all_points) # could be computed more sofisticated
        self.find_projection_area()
        self.shoot_number = (2*self.LAI*self.crown_projection_area)/self.s_area
        print('number of shoots: ',self.shoot_number)
        self.distribute_shoots()


    def load_points(self, veg_path):
        """
        Load the list of points representing the vegetation point cloud.
        @param veg_path: Path to the file with point coordinates.
        @return: List of the points. It means list of point coordinates.
        """
        print(Back.BLUE+'Loading points:'+Style.RESET_ALL)
        start_time = time.time()
        t_file_name = os.path.join(veg_path, self.name+'_all.obj')
        t_file = open(t_file_name, 'r')
        t_csv_file = csv.reader(t_file, delimiter=' ')
        for row in tqdm(t_csv_file):
            if row[0] == 'v':
                self.all_points.append([float(row[1]), float(row[2]), float(row[3])])
        t_file.close()
        print('Load points from ' + t_file_name + ' - done.')
        print('It takes %s seconds.' % (time.time()-start_time))
        print('--------------------------------------------------------------')
        return self.all_points

    def find_projection_area(self):
        """
        Calculation of the projection area of tree crown. It calculates the distance of all points from the center of the tree crown. The radius of the crown projection is define as 90 percentil. 
        @return: tree crown projection area
        """
        print(Back.BLUE+'Computing crown projection area:'+Style.RESET_ALL)
        start_time = time.time()
        d_arr = np.sqrt((np.array(self.all_points)[:,0]-self.center[0])**2+(np.array(self.all_points)[:,2]-self.center[1])**2)
        rad = np.percentile(d_arr,90)
        self.crown_projection_area = rad**2*pi
        print('Projection area calculated.')
        print('Radius is: %f, Projection area is: %f' % (rad,self.crown_projection_area))
        print('center: ', self.center)
        print('It takes %s seconds.' % (time.time()-start_time))
        print('--------------------------------------------------------------')
        
    def distribute_shoots(self):
        """
        Computation of the shoot position based on spatial distribution of point cloud. Generate a files with transformation information of the needle shoot model separately for current and older shoots. The procedure use a cluster method k-mean to determine the best position for the shoot in each height level.
        @return: nothing. Only create the files.
        note:
         - the first idea was to find points in each cube with local function find_cube and then find the positions of shoots there.
         - the first update was to resort the points according to z-coordinate level (the height of the level is determined by user, it is the size of cube for voxelization of the data) with function numpy.searchsorted, than one by one resorted the height level by x coordinate and separate it to the lines and than each line by line sorted by y-coordinate, and it separate the points into the cubes instead the function find_cube. It was much faster. The commented block in this function managed that. The problem was, that the final distribution of positions was deviated by cube net, and it is not natural, in z-coordinate it is not seen, but in x,y- coordinate it was significantly seen. The best solution would be to solve the artificial net removed, but for now it is not solved. After this would be faster to implement the commented block again.
         - it would be needed to implement the multiprocessing here, it is the most slow part of the code
        """
        print(Back.BLUE+'Finding all the clusters for shoot distribution:'+Style.RESET_ALL)
        start_time = time.time()
        shoot_coef = len(self.all_points)/self.shoot_number
        origin = np.amin(self.all_points, axis=0)
        end = np.amax(self.all_points, axis=0)
        num_cubes_x = int((end[0] - origin[0])/self.cluster_cs)
        num_cubes_y = int((end[2] - origin[2])/self.cluster_cs)
        num_cubes_z = int((end[1] - origin[1])/self.cluster_cs)
        self.all_points = sorted(self.all_points, key=lambda x: x[1])
        vox_out_cubes = self.all_points
        self.all_pos = []
        self.cl_results = []
        arr_c_lvl_ind = []
        for i_z in tqdm(range(num_cubes_z+1)):
            if len(vox_out_cubes)!=0:
                cube_slvl_ind = np.searchsorted(np.array(vox_out_cubes)[:,1],origin[1]+((i_z+1)*self.cluster_cs),side='left')
                if cube_slvl_ind!=0:
                    vox_in_lvl = vox_out_cubes[:cube_slvl_ind]
                    vox_in_lvl = sorted(vox_in_lvl, key=lambda x: x[0])
                    vox_out_cubes = vox_out_cubes[cube_slvl_ind:]
                    shoots_in_cube = int(len(vox_in_lvl)/shoot_coef)
                    if shoots_in_cube != 0:
                        vox_data = np.array(vox_in_lvl)
                        centroids = kmeans(vox_data, shoots_in_cube)[0]
                        self.all_pos.extend(centroids)
         ##--------------------------------------- it would be shame not to use this block (below) ---------------------------------------
                    #vox_out_line = vox_in_lvl
                    #for i_x in range(num_cubes_x+1):
                        #if len(vox_out_line)!=0:
                            #cube_line_ind = np.searchsorted(np.array(vox_out_line)[:,0],origin[0]+((i_x+1)*self.cluster_cs),side='left')
                            #if cube_line_ind!=0:
                                #vox_in_line = vox_out_line[:cube_line_ind]
                                #vox_in_line = sorted(vox_in_line,key=lambda x: x[2])
                                #vox_out_line = vox_out_line[cube_line_ind:]
                                #vox_out_cube = vox_in_line
                                #for i_y in range(num_cubes_y+1):
                                    #if len(vox_out_cube)!=0:
                                        #in_cube_ind = np.searchsorted(np.array(vox_out_cube)[:,2],origin[2]+((i_y+1)*self.cluster_cs),side='left')
                                        #if in_cube_ind!=0:
                                            #cube_origin = [origin[0]+(i_x*self.cluster_cs), origin[1]+(i_z*self.cluster_cs), origin[2]+(i_y*self.cluster_cs)]
                                            #vox_in_cube = vox_out_cube[:in_cube_ind]
                                            #vox_out_cube = vox_out_cube[in_cube_ind:]
                                            #t_vox_in_cube, t_vox_out_cubes = self.get_shoots_in_cube(vox_in_cube, cube_origin, self.cluster_cs)
                                            #shoots_in_cube = int(len(t_vox_in_cube)/shoot_coef)
                                            #if shoots_in_cube != 0:
                                                #vox_data = np.array(t_vox_in_cube)
                                                #centroids = kmeans(vox_data, shoots_in_cube)[0]
                                                #self.all_pos.extend(centroids)
                                            #del t_vox_in_cube
                                            #del t_vox_out_cubes
        ##del vox_in_cube, vox_in_line, vox_in_lvl
        ## --------------------------------------- it would be shame not to use this block (above) ---------------------------------------
        del vox_in_lvl
        print(self.all_pos)
        print('The clusters found.')
        print('It takes %s seconds.' % (time.time()-start_time))
        print('--------------------------------------------------------------')
        print(Back.BLUE+'Distributing the shoots into the tree crown and separate them into two groups:'+Style.RESET_ALL)
        start_time = time.time()
        self.age_separation(origin, end)
        t_file_edge_name = self.gen_setup.cur_pos_path
        t_file_edge = open(t_file_edge_name, 'w')
        t_file_edge_csv = csv.writer(t_file_edge, delimiter=' ')
        for i_vox in tqdm(self.current_pos):
            angle = self.get_shoot_angle(i_vox[1])
            t_line = [i_vox[0], i_vox[1], i_vox[2], angle]
            t_file_edge_csv.writerow(t_line)
            del t_line
        t_file_in_name = self.gen_setup.old_pos_path
        t_file_in = open(t_file_in_name, 'w')
        t_file_in_csv = csv.writer(t_file_in, delimiter=' ')
        for i_vox in tqdm(self.older_pos):
            angle = self.get_shoot_angle(i_vox[1])
            t_line = [i_vox[0], i_vox[1], i_vox[2], angle]
            t_file_in_csv.writerow(t_line)
            del t_line
        t_file_edge.close()
        t_file_in.close()
        print('Distribution files created.')
        print('It takes %s seconds.' % (time.time()-start_time))
        print('--------------------------------------------------------------')

    def find_clusters_in_lvl(self, i, arr_c_lvl_ind, shoot_coef):
        # wrong indexing
        #if i==0:
            #cube_slvl_ind = arr_c_lvl_ind[i]
        #else:
            #cube_slvl_ind = arr_c_lvl_ind[i]-arr_c_lvl_ind[i-1]
        #if cube_slvl_ind!=0:
        if i==0:
            vox_in_lvl = self.all_points[arr_c_lvl_ind[i-1]:arr_c_lvl_ind[i]]
        else:
            vox_in_lvl = self.all_points[:arr_c_lvl_ind[i]]
        vox_in_lvl = sorted(vox_in_lvl, key=lambda x: x[0])
        #vox_out_cubes = vox_out_cubes[cube_slvl_ind:]
        shoots_in_cube = int(len(vox_in_lvl)/shoot_coef)
        if shoots_in_cube != 0:
            vox_data = np.array(vox_in_lvl)
            centroids = kmeans(vox_data, shoots_in_cube)[0]
            self.all_pos.extend(centroids)
            #return centroids
        #else:
            #return []

    def age_separation(self, origin, end):
        """
        Separation of the shoot positions into two age classes. Calculation is based on the distance of each position from center of the tree (calculating before) and the known percentage of current shoots depending on the tree height. 
        @param origin: the origin of all points from foliage point cloud (the minimum value of all points in three dimensions)
        @param end: the end of the all points from foliage point cloud (the maximum value of all points in three dimensions)
        @return: Not directly. Fill the list of positions representing the current and older shoots positions (self.older_pos and self.current_pos)
        note: Here is the update from the last version. We not compute the envelop according the voxelized height level, but finding the furthest amount of positions from the center of the tree according to percentage of current shoots in each height level.
        """
        print(Fore.CYAN+'Separation shoot positions into two groups:'+Style.RESET_ALL)
        start_time = time.time()
        num_cubes_x = int((end[0] - origin[0])/self.env_cs)+1
        num_cubes_y = int((end[2] - origin[2])/self.env_cs)+1
        num_cubes_z = int((end[1] - origin[1])/self.env_cs)+1
        self.all_pos = sorted(self.all_pos, key=lambda x: x[1])
        dist = np.zeros((len(self.all_pos),1), dtype=float)
        pos_out_cubes = np.append(self.all_pos,dist, axis=1)
        pos_out_cubes[:,3] = np.sqrt((pos_out_cubes[:,0]-self.center[0])**2+(pos_out_cubes[:,2]-self.center[1])**2)
        for i_z in tqdm(range(num_cubes_z+1)):
            cube_slvl_ind = np.searchsorted(np.array(pos_out_cubes)[:,1],origin[1]+((i_z+1)*self.env_cs),side='left') # for quicker selection of the z-level cubes, it was sorted
            if cube_slvl_ind!=0:
                pos_in_lvl = pos_out_cubes[:cube_slvl_ind]
                pos_out_cubes = pos_out_cubes[cube_slvl_ind:]
                lim_per = self.get_per(((i_z+1)*self.env_cs)-self.env_cs/2)
                no_cur_pos = floor(len(pos_in_lvl)*lim_per)
                if no_cur_pos==0:
                    self.older_pos.extend(pos_in_lvl)
                else:
                    no_old_pos = len(pos_in_lvl)-no_cur_pos
                    pos_in_lvl = sorted(pos_in_lvl, key=lambda x: x[3])
                    self.older_pos.extend(np.array(pos_in_lvl)[:no_old_pos+1,:-1])
                    self.current_pos.extend(np.array(pos_in_lvl)[no_old_pos+1:,:-1])
        print('Shoot positions distributed.')
        print('It takes %s seconds.' % (time.time()-start_time))
        print('--------------------------------------------------------------')
    
    def get_per(self,z_coo):
        """
        Determine the percentage of the current shoots/needles for the given height level (z-coo) of the tree.
        @param z_coo: z-coordinate corresponding to the height level at the tree.
        @return: The percentage of the current shoots/needles in the given height level
        """
        dis = 0.8
        sd = uniform(-0.05, 0.05)
        if z_coo >= self.max_veg-dis:
            per = (0.66 + sd)
        elif self.max_veg-dis > z_coo >= self.max_veg-(dis*2):
            per = (0.68 + sd)
        elif self.max_veg-(dis*2) > z_coo >= self.max_veg-(dis*3):
            per = (0.48 + sd)
        elif self.max_veg-(dis*3) > z_coo >= self.max_veg-(dis*4):
            per = (0.31 + sd)
        elif self.max_veg-(dis*4) > z_coo >= self.max_veg-(dis*5):
            per = (0.26 + sd)
        elif self.max_veg-(dis*5) > z_coo >= self.max_veg-(dis*6):
            per = (0.24 + sd)
        elif self.max_veg-(dis*6) > z_coo >= self.max_veg-(dis*7):
            per = (0.18 + sd)
        elif self.max_veg-(dis*7) > z_coo >= self.max_veg-(dis*8):
            per = (0.10 + sd)
        elif self.max_veg-(dis*8) > z_coo >= self.max_veg-(dis*9):
            per = (0.07 + sd)
        elif self.max_veg-(dis*9) > z_coo:
            per = 0.05
        return per

    def get_shoot_angle(self, z_coo):
        """
        Definition of the shoot elevation angle (zero is on the horizontal level - perpendicular to the trunk/axes of the tree) depending on height in the tree.
        @param z_coo: z-coordinate of the shoot location
        @return: zenith angle of the shoot - given angle is adjusted to rotation calculation -> the zero is on from above
        note:
         - could be separated to current and the older needles - according to Barták 1992 we are able to define the angle for all age classes of shoots
         - in the future for the generalization of the script, here should be the option for selection of the method how to define LAD, if this way, to set the values for each height level at the tree or by LAD function (as it made in case of eucalipt trees or equation)
        """
        if z_coo >= self.max_veg-2:
            angle = (35 + uniform(-5, 12)) * pi/180
        elif self.max_veg-2 > z_coo >= self.max_veg-3:
            angle = (5 + uniform(-5, 15)) * pi/180
        elif self.max_veg-3 > z_coo >= self.max_veg-4:
            angle = (-15 + uniform(-5, 30)) * pi/180
        elif self.max_veg-4 > z_coo >= self.max_veg-5:
            angle = (-35 + uniform(-10, 40)) * pi/180
        elif self.max_veg-5 > z_coo >= self.max_veg-6:
            angle = (-45 + uniform(-5, 40)) * pi/180
        elif self.max_veg-6 > z_coo >= self.max_veg-7:
            angle = (-25 + uniform(-15, 20)) * pi/180
        elif self.max_veg-7 > z_coo:
            angle = (-35 + uniform(-15, 15)) * pi/180
        angle = pi/2 - angle
        return angle
    
    def create_tree_obj_file(self):
        """
        Create obj file with current and older needle shoots and wooden skeleton. It is application of distribution files with coordinates of each shoot model and its angle of rotation.
        @return: nothing. Only create a obj file with shoots
        """
        print(Back.BLUE+'Distributing shoot object and creating the whole tree obj file:'+Style.RESET_ALL)
        start_time = time.time()
        try:
            shutil.copyfile(self.gen_setup.wooden_obj_fin_path, self.gen_setup.tree_obj_path)
            obj_file = open(self.gen_setup.tree_obj_path, 'r')
            with obj_file as f:
                with open(self.gen_setup.tree_obj_path[:-4]+'_tmp','w') as f2: 
                    f2.write('# Created: %s %s\n' % (date.today().strftime("%B %d, %Y"), datetime.now().strftime("%d/%m/%Y %H:%M:%S")))
                    f2.write('# Directory with source data: %s\n' % self.gen_setup.source_dir)
                    #f2.write('# Tree parameters:%s height\t| %d || LAI\t| %d\n' % (self.gen_setup.tree_name, self.max_veg, self.LAI))
                    f2.write('# \n')
                    f2.write('# \n')
                    f2.write(obj_file.read())
            os.rename(self.gen_setup.tree_obj_path[:-4]+'_tmp',self.gen_setup.tree_obj_path)
            obj_file.close()
            cur_distr_file = open(self.gen_setup.cur_pos_path, 'r')
            cur_distr_csv_file = csv.reader(cur_distr_file, delimiter=' ')
            old_distr_file = open(self.gen_setup.old_pos_path, 'r')
            old_distr_csv_file = csv.reader(old_distr_file, delimiter=' ')
            self.write_shoots(old_distr_csv_file,'older')
            self.write_shoots(cur_distr_csv_file,'current')
            obj_file.close()
            cur_distr_file.close()
            old_distr_file.close()
            print('obj file created.')
        except FileNotFoundError:
            print(Style.BRIGHT+Fore.MAGENTA+'obj file is not created. First you must initiate the tree.'+Style.RESET_ALL)
            print('Run function '+Style.BRIGHT+'initiate_tree'+Style.RESET_ALL+' form Tree class')
        print('It takes %s seconds.' % (time.time()-start_time))
        print('--------------------------------------------------------------')

    def load_shoot_voxels(self,shoot_file):
        """
        Load voxels from shoot obj file. Only voxels not facets.
        @param shoot_file: Obj file with shoot voxel coordinates.
        @return: voxel array with the needle shoot
        """
        vox_arr = []
        for i_row in shoot_file:
            if i_row[0] == 'v':
                vox_arr.append([float(i_row[1]), float(i_row[2]), float(i_row[3])])
        return vox_arr
    
    def write_shoots(self, dist_file,description):
        """
        Transformation of shoot voxels by given distribution file (with transformation and rotation setting)
        @return: nothing only add shoot voxels and facest to the obj file of the tree.
        """
        obj_file = open(self.gen_setup.tree_obj_path, 'r')
        lines = obj_file.read()
        last_voxel_id = lines.count('v ')
        obj_file.close()
        obj_file = open(self.gen_setup.tree_obj_path, 'a')
        obj_csv_file = csv.writer(obj_file, delimiter=' ')
        shoot_file = open(self.gen_setup.shoot_path, 'r')
        shoot_csv_file = csv.reader(shoot_file, delimiter=' ')
        shoot_vox_arr = self.load_shoot_voxels(shoot_csv_file)
        shoot_file.close()
        shoot_file = open(self.gen_setup.shoot_path, 'r')
        shoot_csv_file = csv.reader(shoot_file, delimiter=' ')
        shoot_vox_num = len(shoot_vox_arr)
        ind_shoot = 0
        obj_file.write('o %s shoots\n' % description)
        for i_row in tqdm(dist_file):
            trans_info = [float(i_row[0]), float(i_row[1]), float(i_row[2])]
            rot_info = float(i_row[-1])
            trans_vox_arr = self.transform(shoot_vox_arr, trans_info, rot_info)
            ind_vox = 0
            for i_row_shoot in shoot_csv_file:
                if i_row_shoot[0] == 'v':
                    t_line = ['v']+trans_vox_arr[ind_vox]
                    ind_vox += 1
                elif i_row_shoot[0] == 'f':
                    vox_1 = str(int(float(i_row_shoot[1])+ind_shoot*shoot_vox_num+last_voxel_id))
                    vox_2 = str(int(float(i_row_shoot[2])+ind_shoot*shoot_vox_num+last_voxel_id))
                    vox_3 = str(int(float(i_row_shoot[3])+ind_shoot*shoot_vox_num+last_voxel_id))
                    t_line = ['f'] + [vox_1, vox_2, vox_3]
                elif i_row_shoot[0] == 'g':
                    t_line = i_row_shoot
                #else:
                    #if i_row_shoot[0] == '#':
                        #pass
                    #else:
                        #t_line = i_row_shoot
                try:
                    obj_csv_file.writerow(t_line)
                    del t_line
                except UnboundLocalError:
                    pass
            shoot_file.close()
            shoot_file = open(self.gen_setup.shoot_path, 'r')
            shoot_csv_file = csv.reader(shoot_file, delimiter=' ')
            ind_shoot += 1
        obj_file.close()

    def transform(self, vox_arr, loc, angle):
        """
        Recalculate voxels of shoot model into new coordinates after translation and rotation.
        @param vox_arr: Array of shoot model voxels to transformation.
        @param loc: New location of the shoot.
        @param angle: Angle for rotation of the shoot.
        @return: New set of voxel coordinates for shoot.
        """
        alpha = atan(abs(loc[2])/abs(loc[0]))
        if loc[0] > 0 and loc[2] < 0:
            alpha = - alpha
        elif loc[0] < 0 and loc[2] > 0:
            alpha = pi - alpha
        elif loc[0] < 0 and loc[2] < 0:
            alpha = -pi + alpha
        else:
            pass
        beta = uniform(-pi/4, pi/4)
        gama = angle
        psi = alpha+beta+pi
        t_vox_arr = []
        for i_vox in vox_arr:
            x_rot_1 = (i_vox[0]*cos(gama)-i_vox[1]*sin(gama))
            y_rot_1 = i_vox[2]
            z_rot_1 = (i_vox[0]*sin(gama)+i_vox[1]*cos(gama))
            x_rot = (cos(psi)*x_rot_1)-(sin(psi)*y_rot_1)
            y_rot = (sin(psi)*x_rot_1)+(cos(psi)*y_rot_1)
            z_rot = z_rot_1
            x_tra = x_rot + loc[0]
            y_tra = y_rot + loc[2]
            z_tra = z_rot + loc[1]
            t_vox = [x_tra, z_tra, y_tra]
            t_vox_arr.append(t_vox)
        return t_vox_arr
